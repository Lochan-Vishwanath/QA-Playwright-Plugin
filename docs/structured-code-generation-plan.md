# QA Logic Extraction & Structured Code Generation Plan

## 1. The Core Problem
Raw Playwright code (generated by recording or generic LLMs) lacks the **Project DNA** - the specific Page Object Models (POM), helper functions, and architectural patterns of the target repository.

To solve this, we must shift from **"Generating Code"** to **"Refactoring into Structure"**. We need a mechanism that "reads" the existing codebase structure and forces new code to conform to it.

## 2. Research Findings (How Top Tools Work)

Our analysis of tools like **Cursor**, **Claude Code**, and internal systems reveals a common 3-step pipeline for "Context-Aware" generation:

### A. The "Skeleton" Map (Indexing)
Tools do NOT read every file every time. They maintain a lightweight index of the codebase's *shape*.
- **Technique**: **Tree-sitter** or AST parsing.
- **What they store**: Class names, Method signatures, and crucially, **Locators/Selectors** used inside those methods.
- **Why**: This allows the tool to know that `LoginPage.login()` exists without reading the implementation details.

### B. Selector-Based Relevance (The "Glue")
When a user provides raw code (e.g., `await page.fill('#username', '...')`), the tool searches the index for that selector.
- **Match**: If `'#username'` exists in `src/pages/LoginPage.ts`, that file is flagged as **Highly Relevant**.
- **Action**: The LLM is then told, "The user wants to interact with `#username`. We already have a method for this in `LoginPage`. Use it."

### C. Just-In-Time Context
The prompt sent to the LLM is a "Sandwich":
1.  **System Layer**: "You are a refactoring engine. Strict strict adherence to these patterns..."
2.  **Context Layer**: *Signatures* of the matched Page Objects (not full code).
3.  **Task Layer**: The raw recording.

---

## 3. Implementation Plan for QA Playwright Plugin

We will implement a **Smart Refactor Pipeline** that mimics this behavior.

### Phase 1: The Indexer (Structural Understanding)
We need a lightweight script to scan the user's project and build a "Knowledge Graph" of their POMs.

**Proposed Tooling**:
- **Parsers**: `typescript-estree` (simpler than Tree-sitter for JS/TS-only projects) or `grep` (mvp).
- **Output**: `pom-index.json`

**Data Structure (`pom-index.json`)**:
```json
{
  "pages": {
    "LoginPage": {
      "path": "src/pages/login.po.ts",
      "methods": [
        { "name": "login", "args": ["user", "pass"], "locators": ["#username", "#password", "#submit"] }
      ],
      "locators": ["#username", "#password", "#submit"]
    },
    "DashboardPage": {
      "path": "src/pages/dashboard.po.ts",
      "locators": [".nav-bar", ".logout-btn"]
    }
  }
}
```

### Phase 2: The Refactor Agent (The Logic)
This agent replaces the "Copy-Paste to ChatGPT" workflow.

**Workflow**:
1.  **Input**: User inputs raw Playwright code (e.g., from `npx playwright codegen`).
2.  **Scan**: Plugin extracts all selectors from input (`#username`, `.nav-bar`).
3.  **Match**: Plugin looks up selectors in `pom-index.json`.
    - Found `#username` in `LoginPage`.
    - Found `.nav-bar` in `DashboardPage`.
4.  **Prompt Construction**:
    ```markdown
    Refactor this raw code into the project's structure.

    AVAILABLE PAGE OBJECTS (Use these instead of raw page calls):
    - LoginPage (src/pages/login.po.ts): login(user, pass)
    - DashboardPage (src/pages/dashboard.po.ts): [methods...]

    RAW CODE:
    await page.fill('#username', 'admin');
    await page.click('#submit');

    CONSTRAINT:
    - If a method exists (like login), USE IT.
    - If a locator exists but no public method uses it, SUGGEST ADDING A METHOD to that Page Object.
    - Do not use raw 'page.fill' if a Page Object handles it.
    ```
5.  **Output**: Structured, clean code.

### Phase 3: The "Fitter" (File System Operations)
Instead of just printing code, the plugin should offer to **Apply** it.
1.  **Parse Response**: Identify which chunks belong to which files.
2.  **Smart Insert**:
    - **New Test**: Create `tests/feature-x.spec.ts` (based on existing test folder pattern).
    - **Update POM**: Inject new methods into `src/pages/login.po.ts` (using AST insertion to put it inside the class).

---

## 4. Step-by-Step Build Instructions

### Step 1: Create the Analyzer
Write a script `src/analyzer/index.ts` that:
1.  Walks `src/` (or user-configured folder).
2.  Identifies files that look like Page Objects (e.g., end in `.po.ts` or `Page.ts` or contain `class .*Page`).
3.  Parses them to extract Class Name, Methods, and Locator strings.
4.  Saves to `.qa-plugin/index.json`.

### Step 2: Create the "Code Mapper"
Write `src/mapper/matcher.ts` that:
1.  Takes a string of raw code.
2.  Regex extracts `['".*?']` (potential selectors).
3.  Returns a list of `RelevantPageObjects`.

### Step 3: The LLM Prompt Template
Create a prompt template in `src/templates/refactor.ts`. Here is the specific prompt structure to use:

```typescript
export const REFACTOR_PROMPT = \`
You are an expert Playwright Test Engineer specializing in the Page Object Model (POM) pattern.
Your goal is to refactor raw, recorded Playwright code into clean, maintainable code that strictly follows this project's existing structure.

### 1. THE CONTEXT (Existing Page Objects)
The following Page Objects are available in the project. We have identified them as relevant based on the selectors used in the raw code.
ONLY use the methods listed below. Do NOT invent new methods unless absolutely necessary.

\${relevantPageObjectsContext}

### 2. THE RAW INPUT
\${rawCode}

### 3. THE REQUIREMENTS
- **Pattern Matching**: Replace raw \`page.click()\` or \`page.fill()\` calls with the corresponding Page Object methods.
- **Instantiation**: If a Page Object is needed, instantiate it at the top of the test (e.g., \`const loginPage = new LoginPage(page);\`).
- **Missing Methods**: If the raw code performs an action that has NO matching method in the Page Object:
  - Option A: Create a NEW method in the Page Object class definition (wrapped in a \`// NEW METHOD\` comment).
  - Option B: Use the existing public locators if available.
- **Assertions**: Convert generic assertions to Playwright's \`expect()\` pattern.

### 4. OUTPUT FORMAT
Return ONLY the code blocks.
- Block 1: The Refactored Test Code.
- Block 2: (Optional) Updates to Page Object files (if new methods were added).
\`;
```

### Step 4: The "Applier"
Use `ts-morph` or simple string manipulation to:
1.  Read the target file.
2.  Find the end of the Class definition.
3.  Insert the new method before the closing brace `}`.

## 5. Why This is Better than "Copy-Paste"
1.  **Deterministic Context**: You aren't guessing which files to paste. The Indexer *knows* strictly based on the selectors used.
2.  **Scalable**: Works for 10 files or 1000 files. The "Context Sandwich" ensures the LLM context window never overflows, because we only send the *signatures* of *relevant* pages.
3.  **Self-Healing**: If the user changes a POM, re-running the Indexer updates the knowledge graph instantly.

## 6. Edge Cases & Solutions
- **Dynamic Selectors**: "What if the selector is constructed at runtime?"
  - *Solution*: Fallback to "Semantic Search" (embeddings) if exact text match fails. (Future feature).
- **Generic Selectors**: "Divs and Spans match everything."
  - *Solution*: Ignore common/short selectors (length < 4 chars) during indexing.
- **Multiple Matches**: "Login button is on 5 pages."
  - *Solution*: Present choices to the user or pick the file with the most *other* matching selectors (Cluster Matching).
